"""
MkDocs plugin: generate SUMMARY.md for literate-nav.

Listed between gen-files and literate-nav in mkdocs.yml so it
runs after all generator scripts but before nav is consumed.

Logic ported from cmip7-guidance generate_nav.py hook.
"""

import os
import re
import yaml
from pathlib import Path
from mkdocs.plugins import BasePlugin


# ── Helpers ──────────────────────────────────────────────────────────────────

def clean_name(name):
    """Remove numeric prefix from name."""
    return re.sub(r'^\d+[-_.](?=\w)', '', name)


def clean_title_folder(name):
    """Convert folder name to display title."""
    return clean_name(name).replace('_', ' ').replace('-', ' ')


def clean_title_file(filename):
    """Convert filename to display title."""
    name = filename.replace('.md', '').replace('.html', '')
    return clean_name(name).replace('_', ' ').replace('-', ' ')


def get_sort_key(name):
    """Get sort key for ordering."""
    base = name.replace('.md', '').replace('.html', '')
    match = re.match(r'^(\d+)[-_.]', base)
    if match:
        return (int(match.group(1)), name.lower())
    return (9999, name.lower())


EXCLUDE_DIRS = {'scripts', 'assets', 'stylesheets', '__pycache__'}
EXCLUDE_FILES = {'SUMMARY.md', 'links.yml'}


def _find_duplicate_clean_names(path):
    """Find clean names that have a numbered equivalent in the same directory.

    When both '01_Models/' and 'Models/' exist, 'Models' is the duplicate.
    Same for files: '01_submission-guide.md' and 'submission-guide.md'.
    """
    all_names = [item.name for item in path.iterdir()]
    numbered_clean = set()
    for name in all_names:
        clean = clean_name(name)
        if clean != name:  # has a numeric prefix
            numbered_clean.add(clean)
    return numbered_clean


# ── Tree building ────────────────────────────────────────────────────────────

def build_tree(docs_path):
    """Build top-level directory tree.

    Only includes .md files (not .html — those are standalone pages
    generated by scripts and served directly, not processed by MkDocs).
    Skips clean-name directories when a numbered equivalent exists.
    """
    dup_clean_names = _find_duplicate_clean_names(docs_path)
    items = []

    for item in docs_path.iterdir():
        if item.name.startswith('.') or item.name.startswith('_'):
            continue
        if item.name in EXCLUDE_DIRS or item.name in EXCLUDE_FILES:
            continue

        # Skip clean-name duplicates (e.g. 'Models' when '01_Models' exists)
        if item.name in dup_clean_names:
            continue

        if item.is_file() and item.suffix == '.md':
            items.append({
                'type': 'file',
                'name': item.name,
                'path': item.name,
                'sort': get_sort_key(item.name),
            })
        elif item.is_dir():
            subtree = build_subtree(item, docs_path)
            if subtree is not None:  # None means empty, [] means has index.md only
                items.append({
                    'type': 'dir',
                    'name': item.name,
                    'children': subtree,
                    'sort': get_sort_key(item.name),
                })

    return items


def build_subtree(dir_path, base_path):
    """Build subtree recursively.

    index.md is excluded from children — literate-nav handles it via implicit_index.
    Only .md files are included (not .html).
    Returns None if directory has no content at all, [] if it only has index.md.
    """
    dup_clean_names = _find_duplicate_clean_names(dir_path)
    has_index = (dir_path / 'index.md').exists()
    items = []

    for item in dir_path.iterdir():
        if item.name.startswith('.') or item.name.startswith('_'):
            continue
        if item.name == 'index.md':
            continue
        if item.name in dup_clean_names:
            continue

        rel = item.relative_to(base_path)

        if item.is_file() and item.suffix == '.md':
            original_path = str(rel).replace(os.sep, '/')
            items.append({
                'type': 'file',
                'name': item.name,
                'path': original_path,
                'sort': get_sort_key(item.name),
            })
        elif item.is_dir():
            subtree = build_subtree(item, base_path)
            if subtree is not None:
                items.append({
                    'type': 'dir',
                    'name': item.name,
                    'children': subtree,
                    'sort': get_sort_key(item.name),
                })

    # Return None if no content at all (no index, no children)
    if not items and not has_index:
        return None
    return items


# ── Nav generation ───────────────────────────────────────────────────────────

def items_to_nav(items, nav_lines, indent="", base_path=None):
    """Convert items to nav lines.

    Uses original paths (with numeric prefixes) so MkDocs can find files.
    The post_build hook renames files and fixes links after build.
    """
    for item in sorted(items, key=lambda x: x['sort']):
        if item['type'] == 'file':
            title = clean_title_file(item['name'])
            nav_lines.append(f"{indent}- [{title}]({item['path']})")
        else:
            title = clean_title_folder(item['name'])
            if base_path:
                folder_path = base_path / item['name']
                if (folder_path / 'index.md').exists():
                    index_path = f"{item['name']}/index.md"
                    nav_lines.append(f'{indent}- [{title}]({index_path})')
                else:
                    nav_lines.append(f'{indent}- {title}:')
            else:
                nav_lines.append(f'{indent}- {title}:')
            items_to_nav(item['children'], nav_lines, indent + "  ", base_path)


def parse_links(docs_path):
    """Parse custom links from links.yml."""
    links_path = docs_path / 'links.yml'
    if not links_path.exists():
        return []
    try:
        data = yaml.safe_load(links_path.read_text(encoding='utf-8'))
        return data.get('links', []) if data else []
    except Exception:
        return []


def add_links_to_nav(nav_lines, links):
    """Add external links to navigation."""
    if not links:
        return nav_lines

    categories = {}
    root_links = []

    for link in links:
        if not isinstance(link, dict) or 'title' not in link or 'url' not in link:
            continue
        cat = link.get('category')
        if cat:
            categories.setdefault(cat, []).append(link)
        else:
            root_links.append(link)

    for link in root_links:
        nav_lines.append(f"- [{link['title']}]({link['url']})")

    for cat_name in sorted(categories.keys()):
        nav_lines.append(f'- {cat_name}:')
        for link in categories[cat_name]:
            nav_lines.append(f"  - [{link['title']}]({link['url']})")

    return nav_lines


def generate_summary(docs_dir):
    """Generate SUMMARY.md from the docs directory contents."""
    docs_path = Path(docs_dir)
    items = build_tree(docs_path)

    nav_lines = []
    other_items = []

    for item in items:
        if item['type'] == 'file' and item['name'] == 'index.md':
            nav_lines.append('- [Home](index.md)')
        else:
            other_items.append(item)

    items_to_nav(other_items, nav_lines, "", docs_path)

    links = parse_links(docs_path)
    nav_lines = add_links_to_nav(nav_lines, links)

    summary = docs_path / 'SUMMARY.md'
    summary.write_text('\n'.join(nav_lines), encoding='utf-8')
    return len(nav_lines)


# ── Plugin ───────────────────────────────────────────────────────────────────

class NavGeneratorPlugin(BasePlugin):
    """Generate SUMMARY.md after gen-files, before literate-nav."""

    def on_files(self, files, config, **kwargs):
        docs_dir = config['docs_dir']
        docs_path = Path(docs_dir)

        if not docs_path.exists():
            print("[nav-generator] docs_dir does not exist, skipping")
            return files

        count = generate_summary(docs_dir)
        print(f"[nav-generator] Wrote SUMMARY.md ({count} entries)")

        # Safety net: drop any files whose source no longer exists
        before = len(files._files)
        files._files = [f for f in files._files if os.path.exists(f.abs_src_path)]
        removed = before - len(files._files)
        if removed:
            print(f"[nav-generator] Filtered {removed} missing file(s)")

        return files
